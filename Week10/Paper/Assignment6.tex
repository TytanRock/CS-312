% Document Class is specified here. We're using the Homework Template
\documentclass[12pt, a4paper]{article}

\usepackage{graphicx}
\usepackage{float}
\usepackage{geometry}
\usepackage{verbatim}
\usepackage{listings}

\lstset{
  basicstyle=\itshape,
  xleftmargin=3em,
  literate={->}{$\rightarrow$}{2}
           {Îµ}{$\epsilon$}{1}
}

\geometry{a4paper, margin=1in}

\title{Week 10 CS-312 Homework}
\author{
	Cory Ness
	\and
	Jack Engledow
	\and
	James Sgrazzutti
}

\begin{document}

\maketitle

\section{Problem 1}
\subsection{Question}
Show that it is undecidable if two TMs accept the same language.
\subsection{Answer}
Suppose by contradiction there is a Turing Machine $T$ that always decides whether two TMs accept the same language, that is $S_{tm} = \{<A,B>: A$ is a Turing Machine that accepts the same language as $B\}$ where $T$ describes $S_{tm}$. Take two new TMs $A$, $B$, where $A$ will accept any language and $B$ will always run forever.\newline
\newline
Take $T$ and pass $A$ and $B$ into it. Since $T$ is decidable, it will always return an accept or a reject.\newline
\newline
In order to decide anything, it must be determined if $B$ accepts or rejects a string, which is impossible as it will run forever. If we were able to determine if $B$ halts, we could solve this, we cannot due to the halting problem, hence there is a contradiction and TM $T$ cannot exist.

\section{Problem 2}
\subsection{Question}
Show that $ALL_{DFA} \in \mathcal{P}$. That is, show that you can test in polynomial time whether a DFA accepts every string.
\subsection{Answer}
A DFA accepts every string if and only if every state inside it is a final state. Hence, we can perform a search of every reachable node in the DFA (using some graph traversing algorithm such as breadth first which is known to be complete in polynomial time), and if every one of them is final, the DFA accepts every string. Since every operation performed is done in polynomial time, the test is done in polynomial time.

\section{Problem 3}
\subsection{Question}
Show that the set $\mathcal{P}$ is closed under the star operation. (Hint: Dynamic Programming)
\subsection{Answer}
To show that $\mathcal{P}$ is closed under the star operation, we have to show that $x_{1}... x_{n} \in L$ in polynomial time. We can do this inductively, with the base case being $n=0$. With $n=0$, we accept immediately, which is clearly polynomial time. In the inductive step, we prove that $x_{n+1} \in \mathcal{P}$ if $x_{n} \in \mathcal{P}$. This is done by realizing that $x_{n+1}$ is computed the same as $x_{n} + x_{n+1}$, which is clearly computed in polynomial time if $x_{n}$ is calculated in polynomial time. Hence, $\mathcal{P}$ is closed under the star operation.

\section{Problem 4}
\subsection{Question A}
Define SPATH as the set of $<G, a, b, k>$ such that $G$ is a graph with a path from $a$ to $b$ of length at most $k$. Show that SPATH is in $\mathcal{P}$.
\subsection{Question B}
Define LPATH as the set of $<G,a,b,k>$ such that $G$ is a graph with a path from $a$ to $b$ without repeated nodes of length at least $k$. Show that LPATH is $\mathcal{NP}$-Complete. (You may assume NP-completeness of 
HAMPATH).
\subsection{Answer A}
Perform a depth-first search (done in polynomial time) modified such that you don't end when you reach a previously reached node, instead you stop when you reach a node that's been reached in this specific branch of the search. Start at node $a$. During the depth-first search, count down from $k$, if you find $b$ before your count reaches 0, then accept. If your count reaches 0 before finding $b$, end your branch search and move to the next depth. If after the search you never find $b$ before your count reaches 0, then reject. Every operation after the depth-first search is also done in polynomial time (counting down, comparing), hence SPATH is in $\mathcal{P}$.
\subsection{Answer B}


\section{Problem 5}
\subsection{Question}
Show that if $\mathcal{P=NP}$, then every language in $\mathcal{P}$ except $\emptyset$ and $\Sigma^{*}$ is $\mathcal{NP}$-complete.
\subsection{Answer}
We know that $\mathcal{P} \subseteq \mathcal{NP}$. We also know that if $\mathcal{P}=\mathcal{NP}$, then every $\mathcal{NP}$ language is polynomial-time reducible to $\mathcal{P}$. Since every $\mathcal{P}$ language is also $\mathcal{NP}$. Since every $\mathcal{P}$ language is polynomial-time reducible to another language in $\mathcal{P}$, and since $\mathcal{P}=\mathcal{NP}$, every language in $\mathcal{P}$ is polynomial-time reducible to a $\mathcal{NP}$-complete language, hence $\mathcal{P}$ is $\mathcal{NP}$-complete.

\section{Problem 6}
\subsection{Question}
Show that the CLIQUE problem is $\mathcal{NP}$-complete by reducing from VERTEX\_COVER.
\subsection{Answer}

\section{Problem 7}
\subsection{Question}
Convince your instructor that you understood this course.
\subsection{Answer}


\end{document}
